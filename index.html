<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="title" content="Mini Mario â€“ Platformer Modern HTML5 | AsociaÈ›ia Grupul Verde" />
  <meta name="description" content="Mini Mario â€“ joc platformer HTML5/JavaScript modern, responsive, cu controale touch. RuleazÄƒ offline Ã®ntr-un singur fiÈ™ier. Dezvoltat de Marian Dumitru." />
  <meta name="keywords" content="joc Mario, platformer, HTML5, JavaScript, canvas, AsociaÈ›ia Grupul Verde, Marian Dumitru" />
  <meta name="author" content="Marian Dumitru" />
  <meta name="robots" content="index,follow" />
  <meta name="theme-color" content="#141e30" />
  <title>Mini Mario â€“ Platformer Modern HTML5</title>
  <style>
    :root{
      --bg1:#141e30; --bg2:#243b55; --panel:#111827; --panel2:#1f2937; --brand:#2563eb; --brand2:#1d4ed8; --text:#f8fafc; --muted:#94a3b8;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--text);
      background:linear-gradient(to bottom, var(--bg1), var(--bg2));
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display:grid; grid-template-rows:auto auto 1fr auto; justify-items:center;
    }
    header, footer{ width:100%; max-width:1100px; padding:16px; text-align:center; }
    header h1{ margin:0 0 6px 0; font-size: clamp(1.2rem, 2.5vw, 1.8rem); font-weight:800; }
    #hud{ display:flex; gap:18px; justify-content:center; flex-wrap:wrap; font-weight:700 }
    #hud > div{ background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); padding:6px 10px; border-radius:10px }

    .controls{ display:flex; gap:10px; flex-wrap:wrap; justify-content:center; padding:8px }
    .btn{ background:var(--brand); border:none; color:#fff; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:800 }
    .btn:hover{ background:var(--brand2) }

    #gameFrame{ background:var(--panel2); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:8px; box-shadow:0 12px 30px rgba(0,0,0,.35); margin:10px; }
    canvas{ width:min(100vw - 32px, 1024px); height:auto; max-height:72vh; border-radius:10px; image-rendering:pixelated; display:block }

    .touch{ display:none; gap:10px; justify-content:center; padding:8px 0 16px }
    .tbtn{ width:64px; height:64px; border-radius:12px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); display:grid; place-items:center; font-weight:900; font-size:18px; user-select:none }
    .tbtn:active{ transform:scale(.98) }
    @media (max-width: 820px){ .touch{ display:flex } }

    footer{ font-size:12px; color:var(--muted) }
  </style>
</head>
<body>
  <header>
    <h1>ðŸŽ® Mini Mario â€“ Versiune ModernÄƒ (single-file)</h1>
    <div id="hud">
      <div>Monede: <span id="coins">0</span></div>
      <div>VieÈ›i: <span id="lives">3</span></div>
      <div>Nivel: <span id="level">1</span></div>
    </div>
  </header>

  <div class="controls">
    <button class="btn" id="btnReset">ðŸ”„ Reset</button>
    <button class="btn" id="btnMute">ðŸ”Š Sunet</button>
    <span style="align-self:center; opacity:.8">Taste: â—€â–¶ â€¢ Z/SpaÈ›iu = sÄƒriturÄƒ â€¢ R = reset</span>
  </div>

  <div id="gameFrame">
    <canvas id="game" width="960" height="540" aria-label="Mini Mario"></canvas>
  </div>

  <div class="touch">
    <div class="tbtn" data-key="ArrowLeft">â—€</div>
    <div class="tbtn" data-key="ArrowRight">â–¶</div>
    <div class="tbtn" data-key="Space">â¤´</div>
    <div class="tbtn" data-key="KeyX">X</div>
  </div>

  <footer>
    Dezvoltat de Marian Dumitru â€¢ RuleazÄƒ offline â€¢ FÄƒrÄƒ resurse externe
  </footer>

<script>
(() => {
  // ===== Canvas & HUD =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const hudCoins = document.getElementById('coins');
  const hudLives = document.getElementById('lives');
  const hudLevel = document.getElementById('level');
  const btnReset = document.getElementById('btnReset');
  const btnMute = document.getElementById('btnMute');

  // ===== Game constants =====
  const TILE = 32; const GRAV = 0.5; const FRICTION = 0.80; const MAX_FALL = 12; const JUMP_V = -10.8; const SPEED = 3.1;

  // ===== Audio (simple beeps) =====
  let muted=false;
  const AudioCTX = (window.AudioContext||window.webkitAudioContext) ? new (window.AudioContext||window.webkitAudioContext)() : null;
  const beep = (freq=440, dur=0.08, type='square', vol=0.15) => {
    if(!AudioCTX || muted) return; const o = AudioCTX.createOscillator(); const g = AudioCTX.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = vol; o.connect(g); g.connect(AudioCTX.destination);
    const t = AudioCTX.currentTime; o.start(t); o.stop(t+dur);
  };

  // ===== Input (keyboard + touch) =====
  const keys = new Set();
  const keyMap = { 'z':'KeyZ', ' ':'Space' };
  addEventListener('keydown', e=>{ const c = e.code || keyMap[e.key?.toLowerCase()] || e.key; keys.add(c); if(['ArrowLeft','ArrowRight','Space'].includes(c)) e.preventDefault(); }, {passive:false});
  addEventListener('keyup', e=>{ const c = e.code || keyMap[e.key?.toLowerCase()] || e.key; keys.delete(c); });
  document.querySelectorAll('.tbtn').forEach(b=>{
    const c = b.getAttribute('data-key');
    const start=()=>{ keys.add(c); };
    const end = ()=>{ keys.delete(c); };
    b.addEventListener('touchstart', e=>{ e.preventDefault(); start(); }, {passive:false});
    b.addEventListener('touchend', end);
    b.addEventListener('mousedown', start);
    b.addEventListener('mouseup', end);
    b.addEventListener('mouseleave', end);
  });

  // ===== Levels =====
  const levels = [
    { name:'Plaiul Verde', start:{x:2*TILE, y:10*TILE}, tiles:[
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ]},
    { name:'PeÈ™tera Pixel', start:{x:1.5*TILE, y:9*TILE}, tiles:[
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ]}
  ];

  // ===== State =====
  const state = { levelIndex:0, coins:0, lives:3 };
  let camera = {x:0,y:0};
  const player = { x:0,y:0,w:22,h:28,vx:0,vy:0,onGround:false,facing:1,invul:0 };
  const enemies=[]; const coins=[]; let flag=null;

  // ===== Helpers =====
  const tileAt=(x,y)=>{ const L=levels[state.levelIndex]; const tx=Math.floor(x/TILE), ty=Math.floor(y/TILE); if(ty<0||ty>=L.tiles.length||tx<0||tx>=L.tiles[0].length) return 0; return L.tiles[ty][tx]; };
  const solid=t=> t===1||t===2;
  const rectsOverlap=(a,b)=> a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;

  function collideRect({x,y,w,h}, dx, dy){
    let newX=x+dx, newY=y+dy, hitX=false, hitY=false;
    if(dx!==0){ const steps=Math.ceil(Math.abs(dx)), sx=Math.sign(dx); for(let i=0;i<steps;i++){ const nx=x+sx; const corners=[{x:nx,y:y},{x:nx,y:y+h-1},{x:nx+w-1,y:y},{x:nx+w-1,y:y+h-1}]; if(corners.some(c=>solid(tileAt(c.x,c.y)))){ hitX=true; break;} x=nx;} newX=x; }
    if(dy!==0){ const steps=Math.ceil(Math.abs(dy)), sy=Math.sign(dy); for(let i=0;i<steps;i++){ const ny=y+sy; const corners=[{x:newX,y:ny},{x:newX+w-1,y:ny},{x:newX,y:ny+h-1},{x:newX+w-1,y:ny+h-1}]; if(corners.some(c=>solid(tileAt(c.x,c.y)))){ hitY=true; break;} y=ny;} newY=y; }
    return {x:newX,y:newY,hitX,hitY};
  }

  function loadLevel(i){
    state.levelIndex=i; hudLevel.textContent=(i+1); enemies.length=0; coins.length=0; flag=null;
    const L=levels[i]; Object.assign(player,{x:L.start.x,y:L.start.y,vx:0,vy:0,onGround:false,invul:0});
    for(let y=0;y<L.tiles.length;y++) for(let x=0;x<L.tiles[0].length;x++){ const t=L.tiles[y][x]; if(t===4) enemies.push({x:x*TILE+4,y:y*TILE-2,w:24,h:26,vx:1.2,dir:1,alive:true}); if(t===3) coins.push({x:x*TILE+8,y:y*TILE+8,r:6,taken:false,phase:Math.random()*Math.PI*2}); if(t===5) flag={x:x*TILE+8,y:y*TILE-64}; }
  }

  function hitPlayer(){ player.invul=1.2; state.lives--; hudLives.textContent=state.lives; beep(110,0.15,'sine',0.2); if(state.lives<=0){ state.lives=3; state.coins=0; hudLives.textContent=state.lives; hudCoins.textContent=state.coins; loadLevel(0);} else { const L=levels[state.levelIndex]; Object.assign(player,{x:L.start.x,y:L.start.y,vx:0,vy:0}); camera={x:0,y:0}; } }
  const loseLife=()=>hitPlayer();
  function nextLevel(){ loadLevel((state.levelIndex+1)%levels.length); beep(523,0.15,'triangle',0.15); }

  function update(dt){
    // input
    if(keys.has('ArrowLeft')){ player.vx -= 0.6; player.facing=-1; }
    if(keys.has('ArrowRight')){ player.vx += 0.6; player.facing= 1; }
    player.vx *= FRICTION; if(Math.abs(player.vx)<0.05) player.vx=0;
    const wantJump = keys.has('Space') || keys.has('KeyZ'); if(wantJump && player.onGround){ player.vy=JUMP_V; player.onGround=false; beep(660,0.08,'square',0.12); }
    player.vy += GRAV; if(player.vy>MAX_FALL) player.vy=MAX_FALL;

    // move
    const resX = collideRect(player, Math.max(-SPEED, Math.min(SPEED, player.vx)), 0); player.x=resX.x; if(resX.hitX) player.vx=0;
    const resY = collideRect(player, 0, player.vy); player.y=resY.y; if(resY.hitY){ if(player.vy>0) player.onGround=true; player.vy=0; } else player.onGround=false;

    // fall out
    if(player.y > levels[state.levelIndex].tiles.length*TILE + 100){ loseLife(); return; }

    // coins
    for(const c of coins){ if(!c.taken){ const dx=(player.x+player.w/2)-c.x, dy=(player.y+player.h/2)-c.y; if(dx*dx+dy*dy < (c.r+10)*(c.r+10)){ c.taken=true; state.coins++; hudCoins.textContent=state.coins; beep(880,0.12,'triangle',0.12); } } c.phase += dt*4; }

    // enemies
    for(const e of enemies){ if(!e.alive) continue; e.x += e.vx*e.dir; const frontX = e.dir>0? e.x+e.w : e.x-1; const footY=e.y+e.h+1; const aheadSolid = solid(tileAt(frontX, e.y+e.h/2)); const floorAhead = solid(tileAt(frontX, footY)); if(aheadSolid || !floorAhead) e.dir*=-1; if(rectsOverlap(player,e)){ if(player.vy>2){ e.alive=false; player.vy=JUMP_V*0.7; beep(220,0.08,'sawtooth',0.12);} else if(player.invul<=0){ hitPlayer(); } } }

    // flag
    if(flag){ if(player.x+player.w>flag.x && player.x<flag.x+16 && player.y<flag.y+128 && player.y+player.h>flag.y){ nextLevel(); } }

    // invul
    if(player.invul>0) player.invul -= dt;

    // camera
    camera.x = Math.floor(player.x - W/2 + player.w/2); camera.y = Math.floor(player.y - H/2 + player.h/2);
    const L=levels[state.levelIndex]; camera.x = Math.max(0, Math.min(camera.x, L.tiles[0].length*TILE - W)); camera.y = Math.max(0, Math.min(camera.y, L.tiles.length*TILE - H));
  }

  // ===== Drawing =====
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }
  function drawBrick(x,y){ ctx.fillStyle='#b44'; roundedRect(x+1,y+1,TILE-2,TILE-2,6); ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=2; ctx.strokeRect(x+3,y+3,TILE-6,TILE-6); ctx.beginPath(); ctx.moveTo(x+3,y+TILE/2); ctx.lineTo(x+TILE-3,y+TILE/2); ctx.moveTo(x+TILE/2,y+3); ctx.lineTo(x+TILE/2,y+TILE-3); ctx.stroke(); }
  function drawClouds(){ const clouds=[{x:80,y:80,s:1.2},{x:380,y:120,s:1.0},{x:700,y:70,s:1.3},{x:1100,y:90,s:1.1}]; for(const c of clouds){ ctx.save(); ctx.translate(c.x - camera.x*0.4, c.y - camera.y*0.2); ctx.scale(c.s,c.s); ctx.fillStyle='rgba(255,255,255,.9)'; roundedRect(-40,-15,80,30,14); roundedRect(-25,-22,50,20,10); roundedRect(10,-18,40,24,12); ctx.restore(); } }
  function drawTiles(){ const L=levels[state.levelIndex]; for(let y=0;y<L.tiles.length;y++){ for(let x=0;x<L.tiles[0].length;x++){ const t=L.tiles[y][x]; const px=x*TILE - camera.x, py=y*TILE - camera.y; if(t===1){ ctx.fillStyle='#6b4e2e'; roundedRect(px,py+10,TILE,TILE-10,6); ctx.fillStyle='#3e8e41'; roundedRect(px+2,py+2,TILE-4,16,6);} else if(t===2){ drawBrick(px,py);} } } }
  function drawCoins(){ for(const c of coins){ if(c.taken) continue; const bob = Math.sin(c.phase)*3; ctx.save(); ctx.translate(c.x - camera.x, c.y + bob - camera.y); ctx.fillStyle='#ffd23f'; roundedRect(-8,-12,16,24,8); ctx.fillStyle='#ffea88'; roundedRect(-4,-8,8,16,4); ctx.restore(); } }
  function drawEnemies(){ for(const e of enemies){ if(!e.alive) continue; ctx.save(); ctx.translate(e.x - camera.x, e.y - camera.y); ctx.fillStyle='#8b4a2b'; roundedRect(0,0,e.w,e.h,10); ctx.fillStyle='#000'; roundedRect(6,6,6,6,2); roundedRect(e.w-12,6,6,6,2); ctx.restore(); } }
  function drawFlag(){ if(!flag) return; ctx.save(); const x=flag.x - camera.x, y=flag.y - camera.y; ctx.fillStyle='#ddd'; roundedRect(x,y,6,128,3); ctx.fillStyle='#ff4757'; ctx.beginPath(); ctx.moveTo(x+6,y+12); ctx.lineTo(x+60,y+24); ctx.lineTo(x+6,y+36); ctx.closePath(); ctx.fill(); ctx.restore(); }
  function drawPlayer(){ ctx.save(); ctx.translate(player.x - camera.x, player.y - camera.y); if(player.invul>0 && Math.floor(player.invul*20)%2===0){ ctx.globalAlpha=.5; } ctx.fillStyle='#ff6b6b'; roundedRect(0,0,player.w,player.h,6); ctx.fillStyle='#c0392b'; roundedRect(2,-8,player.w-4,10,4); ctx.fillStyle='#111'; roundedRect(6,8,4,6,2); roundedRect(player.w-10,8,4,6,2); ctx.restore(); }

  function draw(){ ctx.clearRect(0,0,W,H); drawClouds(); drawTiles(); drawCoins(); drawEnemies(); drawFlag(); drawPlayer(); const grd = ctx.createRadialGradient(W/2,H/2, W/3, W/2,H/2, W/1.1); grd.addColorStop(0,'rgba(0,0,0,0)'); grd.addColorStop(1,'rgba(0,0,0,.25)'); ctx.fillStyle=grd; ctx.fillRect(0,0,W,H); }

  // ===== Loop =====
  let last=0; function loop(ts){ const dt=Math.min(0.05,(ts-last)/1000||0.016); last=ts; update(dt); draw(); requestAnimationFrame(loop);} requestAnimationFrame(loop);

  // ===== UI Buttons =====
  btnReset.addEventListener('click', ()=> loadLevel(state.levelIndex));
  btnMute.addEventListener('click', ()=>{ muted=!muted; btnMute.textContent = muted ? 'ðŸ”‡ FÄƒrÄƒ sunet' : 'ðŸ”Š Sunet'; });
  addEventListener('keydown', e=>{ if((e.code||e.key)==='KeyR') loadLevel(state.levelIndex); });

  // ===== Start =====
  loadLevel(0);
})();
</script>
</body>
</html>
